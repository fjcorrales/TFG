#LyX 2.3 created this file. For more info see http://www.lyx.org/
\lyxformat 544
\begin_document
\begin_header
\save_transient_properties true
\origin unavailable
\textclass scrbook
\begin_preamble
% increases link area for cross-references and autoname them
% if you change the document language to e.g. French
% you must change "extrasenglish" to "extrasfrench"
\AtBeginDocument{%
 \renewcommand{\ref}[1]{\mbox{\autoref{#1}}}
}
\def\refnamechanges{%
 \renewcommand*{\equationautorefname}[1]{}
 \renewcommand{\sectionautorefname}{sec.\negthinspace}
 \renewcommand{\subsectionautorefname}{sec.\negthinspace}
 \renewcommand{\subsubsectionautorefname}{sec.\negthinspace}
 \renewcommand{\figureautorefname}{Fig.\negthinspace}
 \renewcommand{\tableautorefname}{Tab.\negthinspace}
}
\@ifpackageloaded{babel}{\addto\extrasenglish{\refnamechanges}}{\refnamechanges}

% in case somebody want to have the label "Equation"
%\renewcommand{\eqref}[1]{Equation~(\negthinspace\autoref{#1})}

% that links to image floats jumps to the beginning
% of the float and not to its caption
\usepackage[figure]{hypcap}

% the pages of the TOC is numbered roman
% and a pdf-bookmark for the TOC is added
\let\myTOC\tableofcontents
\renewcommand\tableofcontents{%
  \frontmatter
  \pdfbookmark[1]{\contentsname}{}
  \myTOC
  \mainmatter }

% makes caption labels bold
% for more info about these settings, see
% http://mirrors.ctan.org/macros/latex/contrib/koma-script/doc/scrguien.pdf
\setkomafont{captionlabel}{\bfseries}
\setcapindent{1em}

% enables calculations
\usepackage{calc}

% fancy page header/footer settings
% for more information see section 9 of
% ftp://www.ctan.org/pub/tex-archive/macros/latex2e/contrib/fancyhdr/fancyhdr.pdf
\renewcommand{\chaptermark}[1]{\markboth{#1}{#1}}
\renewcommand{\sectionmark}[1]{\markright{\thesection\ #1}}

% increases the bottom float placement fraction
\renewcommand{\bottomfraction}{0.5}

% avoids that floats are placed above its sections
\let\mySection\section\renewcommand{\section}{\suppressfloats[t]\mySection}
\end_preamble
\options intoc,bibliography=totoc,index=totoc,BCOR10mm,captions=tableheading,titlepage
\use_default_options true
\master TFG.lyx
\begin_modules
customHeadersFooters
\end_modules
\maintain_unincluded_children false
\language spanish
\language_package default
\inputencoding utf8
\fontencoding global
\font_roman "lmodern" "default"
\font_sans "lmss" "default"
\font_typewriter "lmtt" "default"
\font_math "auto" "auto"
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100 100
\font_tt_scale 100 100
\use_microtype false
\use_dash_ligatures true
\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\float_placement h
\paperfontsize 12
\spacing single
\use_hyperref true
\pdf_title "Your title"
\pdf_author "Your name"
\pdf_bookmarks true
\pdf_bookmarksnumbered true
\pdf_bookmarksopen true
\pdf_bookmarksopenlevel 1
\pdf_breaklinks false
\pdf_pdfborder true
\pdf_colorlinks false
\pdf_backref false
\pdf_pdfusetitle false
\pdf_quoted_options "pdfpagelayout=OneColumn, pdfnewwindow=true, pdfstartview=XYZ, plainpages=false"
\papersize a4paper
\use_geometry false
\use_package amsmath 2
\use_package amssymb 2
\use_package cancel 1
\use_package esint 1
\use_package mathdots 1
\use_package mathtools 1
\use_package mhchem 1
\use_package stackrel 1
\use_package stmaryrd 1
\use_package undertilde 1
\cite_engine basic
\cite_engine_type default
\biblio_style plain
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\justification true
\use_refstyle 0
\use_minted 0
\branch NoChildDocument
\selected 0
\filename_suffix 0
\color #ff0000
\end_branch
\index Index
\shortcut idx
\color #008000
\end_index
\secnumdepth 3
\tocdepth 2
\paragraph_separation skip
\defskip medskip
\is_math_indent 1
\math_indentation default
\math_numbering_side default
\quotes_style french
\dynamic_quotes 0
\papercolumns 1
\papersides 2
\paperpagestyle fancy
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Left Header
\begin_inset Argument 1
status open

\begin_layout Plain Layout
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
chaptername
\end_layout

\end_inset


\begin_inset space ~
\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
thechapter
\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
rightmark
\end_layout

\end_inset


\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
Enable page headers and add the chapter to the header line.
\end_layout

\end_inset


\end_layout

\begin_layout Right Header
\begin_inset Argument 1
status open

\begin_layout Plain Layout
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
leftmark
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Left Footer
\begin_inset Argument 1
status open

\begin_layout Plain Layout
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
thepage
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Center Footer

\end_layout

\begin_layout Right Footer
\begin_inset Argument 1
status open

\begin_layout Plain Layout

\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
thepage
\end_layout

\end_inset


\end_layout

\begin_layout Chapter
Desarrollo
\end_layout

\begin_layout Section
Descripción General
\end_layout

\begin_layout Standard
Como se mencionó en la introducción, el desarrollo de esta aplicación será
 principalmente en C++ dado que es el lenguaje en el que se escribe en Unreal
 Engine 5 y ROS2.
 La fase de desarrollo se basa en 2 partes principales.
 Una primera de puesta a punto, o de prototipado, donde se ha experimentado
 con el motor de juego para descubrir la mejor forma de implementar los
 requisitos pedidos.
 Y una segunda fase en la que, ya , en esta primera versión se desarrolla
 la aplicación al completo.
\end_layout

\begin_layout Section
Fase de prototipado
\end_layout

\begin_layout Standard
Esta ha sido la primera fase del desarrollo del simulador, en la cual he
 realizado algunas pruebas para encontrar la mejor forma de implementar
 un dron y su movimiento en el sandbox proporcionado por Unreal.
 Las pruebas realizadas han sido un total de 3 en relación a los elementos
 que personalmente he considerado más importantes para crear un simulador:
 el movimiento, tener una malla, o 
\shape slanted
mesh
\shape default
, con la forma del dron y finalmente el control de la velocidad que usaremos
 para controlar la posición del dron.
\end_layout

\begin_layout Subsection
Pruebas de movimiento de actores:
\end_layout

\begin_layout Standard
Para comenzar, estudie formas de poder mover actores o elementos dentro
 de Unreal.
 En este aspecto cabe destacar que Unreal ofrece una serie clases propias
 que nos permiten crear elementos que situar en la escena a los cuales añadirles
 componentes.
 Estas clases son: actor, peón y personaje, donde cabe decir que las dos
 últimas heredan de actor, lo cual nos indica que todas las funciones de
 actor se encuentran disponibles tanto en peón y personaje.
 Estos elementos son los objetos que podemos añadir a un nivel o escena
 creado en unreal, es decir son los elementos que interactuarán con el entorno
 y el usuario una vez comienza el juego.
 A pesar de que todas sean clases casi hermanas, las principales diferencias
 entre ellas son en relación a que utilidad de Unreal son capaces de usar.
 Los actores son los objetos más límitados ya que estos no ofrecen opción
 a que los maneje la IA ni permiten tener inputs de teclado.
 Los peónes son el siguiente paso en la cadena, los cuales permiten ser
 controlados por la IA de Unreal y permiten inputs de teclado, sin embargo
 no tienen físicas integradas.
 Finalmente nos encontramos a los personajes, estos son actores creados
 principalmente para simular personas, estos incluyen todo lo mencionado
 previamente y además, incluyen las físicas necesarias para simular un humano.
\end_layout

\begin_layout Standard
En cuanto a los de los componentes que se pueden añadir a estos actores,
 estos son elementos que añaden funcionalidad a los mismos.
 Podemos encontrar 2 tipos de componentes: componentes de actor y componenetes
 de escena.
 El componente de actor no hace nada esencialmente, sin embargo es imprescindibl
e dado que es la base del resto de componentes.
 Los componentes de escena son aquellos que podemos usar como apoyo para
 incluir funcionalidades a los actores.
\end_layout

\begin_layout Standard
Ahora, todos estos elementos se integran en el editor de Unreal mediante
 jerarquías donde predominan las acciones que tome el componente raíz de
 la misma.
\end_layout

\begin_layout Standard
(foto de las jerarquías del editor en Unreal)
\end_layout

\begin_layout Standard
Con esto en mente, realicé un primer prototipo para estudiar el movimiento
 en los actores y como poder implementar el movimiento de un dron.
 Tras investigar y revisar tutoriales de diversas fuentes[tutorial de youtube
 y página de unreal] decidí crear un componente de escena que se encargara
 de modificar la localización de una 
\shape slanted
mesh
\shape default
 (malla).
 Es decir, crear un componente de escena que fuera el raíz de la jerarquía
 que moviera un modelo 3D, en este caso de un cubo en base a un vector de
 posición al cual se le podían ajustar las componentes tanto desde el editor
 como desde un blueprint como desde el propio código fuente.
 
\end_layout

\begin_layout Standard
Esta prueba sin embargo no termina aquí,ya que, para indagar también en
 la cuestión de las colisiones, probé a añadir lo que es comúnmente conocido
 como 
\shape slanted
Hitbox 
\shape default
(caja de colisiones).
 Para esto simplemente añadí un componente de escena de tipo hitbox, lo
 ajusté al tamaño de la mesh elegida y configuré un gráfico de eventos para
 que cuando el jugador entrara en contacto con el objeto este empezara a
 moverse.
 Asimismo icluí otra Hitbox para delimitar un área amplia alrededor de la
 malla elegida para que en el caso de que detectara que el jugador abandonaba
 el área el objeto volviera a su posición original.
\end_layout

\begin_layout Standard
A continuación adjunto el código generado para este componente de escena
 
\begin_inset Quotes eld
\end_inset

move.h
\begin_inset Quotes erd
\end_inset

 y 
\begin_inset Quotes eld
\end_inset

move.cpp
\begin_inset Quotes erd
\end_inset

:
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "C:/Users/prestamo_admin/Desktop/TFG/TFG/software/Pruebas/moveTest/moveTest/move.h"
lstparams "caption={Header del componente de escena move},label={Img.1}"

\end_inset


\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "C:/Users/prestamo_admin/Desktop/TFG/TFG/software/Pruebas/moveTest/moveTest/move.cpp"
lstparams "caption={Código fuente del componente de escena move},label={Img.2}"

\end_inset


\end_layout

\begin_layout Standard
Adjunto también el gráfico de eventos creado para esta funcionalidad:
\end_layout

\begin_layout Standard
\begin_inset Graphics
	filename C:/Users/prestamo_admin/Desktop/TFG/TFG/software/Pruebas/moveTest/eventGraph.jpeg
	lyxscale 50
	scale 50
	BoundingBox 0bp 0bp 672bp 672bp

\end_inset


\end_layout

\begin_layout Standard
El código y el gráfico de eventos fue obtenido de la guía creada por Lötwig
 Fusel [referencia que toque]
\end_layout

\begin_layout Standard
Posteriormente, tras este primer acercamiento a los actores y componentes,
 decidí realizar pruebas para intentar implementar un modo de vuelo típico
 de los drones, el modo 
\shape slanted
Hover.
 
\shape default
Este modo es un modo simple en el que el dron se eleva hasta una altura
 pre establecida y la mantiene hasta que se le envíe una señal para moverse
 o volver a su posición original.
\end_layout

\begin_layout Standard
Este caso es muy similar al anterior dado que también he creado un componente
 de escena, sin embargo, hay algún cambio respecto al funcionamiento.
 El código para modificar la posición sigue siendo el mismo, solo que en
 este caso, podemos modificar únicamente la altura máxima que queremos que
 alcance el dron y la velocidad del mismo.
 También implemente dos funciones, una para comenzar el vuelo y otra para
 resetearlo y cabe mencionar que esta vez no se ha implementado ningún grafico
 de eventos dado que la interacción de esta prueba se basa en mandar la
 señal de activación del hover o de reset.
\end_layout

\begin_layout Standard
Adjunto tanto el header como el código del componente en cuestión 
\begin_inset Quotes eld
\end_inset


\shape slanted
HoverComponent
\shape default

\begin_inset Quotes erd
\end_inset

:
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "C:/Users/prestamo_admin/Desktop/TFG/TFG/software/Pruebas/hoverTest/HoverComponent.h"
lstparams "caption={Header del componente de escena HoverComponent},label={Img.3}"

\end_inset


\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "C:/Users/prestamo_admin/Desktop/TFG/TFG/software/Pruebas/hoverTest/HoverComponent.cpp"
lstparams "caption={Código fuente del componente de escena HoverComponent},label={Img.4}"

\end_inset


\end_layout

\begin_layout Standard
Tras desarrollar estos módulos de prueba basados en componentes de escena
 y observar su funcionamiento llegamos a la conclusión de que no se ajustaba
 completamente a los requisitos especificados.
 A pesar de ofrecernos una gran versatilidad a la hora de poder crear objetos
 a base de unir componentes independientes, algo que nos interesaba en gran
 medida, no estabamos desarrollando un actor como tal, si no componentes
 que no podrán comunicarse entre si a no ser que estén completamente integrados
 en un actor.
 Por lo que descartamos estos prototipos y buscamos otra forma de enfocar
 el proyecto basándonos en la creación de un peón e implementar en el mismo
 un control diferencial de la velocidad, prueba que describiremos más adelante.
\end_layout

\begin_layout Subsection
Prueba de importación de mallas:
\end_layout

\begin_layout Standard
Durante el desarrollo de la prueba anteriormente descrita, busqué formas
 de poder integrar un modelo 3D, conocido como 
\shape slanted
mesh
\shape default
, de un cuadricóptero en el editor de Unreal y como hacer que los componentes
 lo movieran.
 
\end_layout

\begin_layout Standard
Para empezar busqué en internet un modelo 3D gratuito de un cuadricóptero[refere
ncia a la página del modelo 3D del dron].
 Una vez descargado faltaba importarlo a la carpeta de contenidos de Unreal
 Engine para su uso.
 Cabe mencionar que estos modelos 3D han de estar exportados de sus respectivas
 aplicaciones en formato .fbx ya que este es el que reconoce Unreal.
 El proceso de importación es muy simple pudiendo simplemente arrastrar
 el archivo al editor y tras una simple ventana de configuración tener ya
 disponible el modelo para su uso.
 El modelo seleccionado fue el siguiente:
\end_layout

\begin_layout Standard
(foto del mesh del dron en el entorno)
\end_layout

\begin_layout Standard
Si se deseata Epic Games también cuenta con una paltaforma en la que los
 usuarios pueden subir sus modelos 3D ya sea de niveles u objetos a una
 tienda online.
 La desventaja es que la mayoría del contenido es de pago.
 
\end_layout

\begin_layout Standard
Con esto quedaba solventado el problema de poder tener un modelo tridimensional
 de un dron.
 A pesar de esto, surje una duda en relación a las colisiones de la 
\shape italic
mesh
\shape default
, pues no sabemos con certeza si el propio Unreal genera las colisiones
 automáticamente al proporcionarle una 
\shape slanted
hitbox
\shape default
 al modelo o si estas han de ser programadas desde 0.
\end_layout

\begin_layout Subsection
Prueba de implementación de un control diferencial de la velocidad:
\end_layout

\begin_layout Standard
Finalmente y tras las primeras pruebas de movimiento decidimos crear un
 peón ya que este es el objeo ideal sobre el que crear un dron dado a las
 características que ofrece, comentadas al principio de este bloque de desarroll
o.
\end_layout

\begin_layout Standard
Así pues, tras crear una clase en C++ de un peón implementamos en la misma
 un control de la velocidad, un concepto simple basado en 3 vectores, uno
 para establecer la velocidad deseada, otro para definir la velocidad real
 del dron y un tercero que se encarga de calcular un delta con la velocidad
 real actual del dron, la velocidad objetivo y el tiempo transcurrido.
 
\end_layout

\begin_layout Standard
Importante comentar que unreal nos proporciona una función tick dentro de
 todas sus clases, la cual se ejecuta a cada frame generado por el motor
 y ejecuta las instrucciones descritas en la misma.
 Al mismo tiempo, esta función nos poporciona una variable 
\shape slanted
DeltaTime
\shape default
 la cual lleva la cuenta del tiempo que pasa dentro del editor durante la
 ejecución del programa.
 Esta función será la que más carga computacional tenga al final, dado que
 es la que utilizaremos para poder generar un movimiento fluido en un futuro.
\end_layout

\begin_layout Standard
Otra función generada automáticamente y que merece la pena comentar es 
\shape slanted
BeginPlay
\shape default
, esta se ejecuta en el primer instante en que se entra al nivel creado
 y solo esa vez.
 Esta resulta utíl para establecer variables iniciales o si por ejemplo
 se desea almacenar la posición inicial de algún objeto.
\end_layout

\begin_layout Standard
Una vez explicados los conceptos anteriores pasamos a la implementación
 del control en cuestión, una implementación simple y que nos permite configurar
 una velocidad máxima, una minima y una constante para ajustar la velocidad
 en el calculo del delta de la velocidad.
 La implementación queda tal que así:
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "C:/Users/prestamo_admin/Desktop/TFG/TFG/software/droneSim/DronePawn.h"
lstparams "caption={Header del peón DronePawn},label={Img.5}"

\end_inset


\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "C:/Users/prestamo_admin/Desktop/TFG/TFG/software/droneSim/DronePawn.cpp"
lstparams "caption={Código fuente del peón DronePawn},label={Img.6}"

\end_inset


\end_layout

\begin_layout Standard
Asimismo, gracias a utilizar un peón tenemos acceso a entradas de teclado
 mediante la función SetupPlayerInputComponent, la cual nos permite aumentar
 y disminuir los valores de las componentes del vector de la velocidad objetivo
 mediante teclas durante la ejecución del nivel.
 Muy relevante tener en cuenta que estos 
\shape italic
keybinds
\shape default
 también han de configurarse dentro del editor de Unreal:
\end_layout

\begin_layout Standard
(insertar captura de la configuración del editor)
\end_layout

\begin_layout Standard
Y no solo eso, si no que además hemos de configurar el DefaultPawn del nivel
 al peón de la clase que hemos creado DronePawn, dado que es este 
\begin_inset Quotes eld
\end_inset

peón por defecto
\begin_inset Quotes erd
\end_inset

 el que recoje las entradas del teclado y las transfiere al propio peón.
 Este cambio solamene lo podemos realizar desde el código del modo de juego
 que se generó autómaticamente al crear el proyecto en Unreal.
 Dentro del archivo NombreProyectoGameModeBase.h y NombreProyectoGameModeBase.cpp
 hemos de añadir las 2 siguientes líneas (En mi caso el nombre de los archivos
 es droneSimGameModeBase.h y droneSimGameModeBase.cpp):
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "C:/Users/prestamo_admin/Desktop/TFG/TFG/software/droneSim/droneSimGameModeBase.h"
lstparams "caption={Header del modo de juego droneSimGameModeBase},label={Img.7}"

\end_inset


\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "C:/Users/prestamo_admin/Desktop/TFG/TFG/software/droneSim/droneSimGameModeBase.cpp"
lstparams "caption={Código fuente del modo de juego droneSimGameModeBase},label={Img.8}"

\end_inset


\end_layout

\begin_layout Standard
Una vez realizados todos estos cambios veremos que aparece esto en el editor
 al ejecutar y seleccionar el peón:
\end_layout

\begin_layout Standard
(imagen de los valores de los vectores)
\end_layout

\begin_layout Standard
Para finalizar esta prueba se intentó configurar que se modificara la posición
 del peón basandose en la posición actual y la velocidad resultante del
 cálculo diferencial.
 Sin embargo no se consiguó hacer que se moviera la cámara.
 Esto puede deberse a varios factores, pero lo más seguro es que sea necesario
 implementar una mesh y cámara para poder observar que el peón se mueva.
\end_layout

\begin_layout Standard
Tras esta última prueba concluímos en que el movimiento del dron basado
 en este control diferencial es justo lo que necesitamos para simular correctame
nte el movimiento y poder realizar una integración con ROS 2 ya que pretendemos
 que el movimiento se rija mediante la velocidad que se enviará mediante
 los servicios de mensajería ofrecidos por ese framework.
\end_layout

\begin_layout Standard
\begin_inset Branch NoChildDocument
inverted 0
status collapsed

\begin_layout Standard
\begin_inset CommandInset bibtex
LatexCommand bibtex
bibfiles "thesisExample"
options "alpha"

\end_inset


\end_layout

\begin_layout Standard
\begin_inset CommandInset nomencl_print
LatexCommand printnomenclature
set_width "custom"
width "2.5cm"

\end_inset


\end_layout

\end_inset


\end_layout

\end_body
\end_document
