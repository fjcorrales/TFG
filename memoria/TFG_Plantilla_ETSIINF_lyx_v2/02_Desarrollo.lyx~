#LyX 2.3 created this file. For more info see http://www.lyx.org/
\lyxformat 544
\begin_document
\begin_header
\save_transient_properties true
\origin unavailable
\textclass scrbook
\begin_preamble
% increases link area for cross-references and autoname them
% if you change the document language to e.g. French
% you must change "extrasenglish" to "extrasfrench"
\AtBeginDocument{%
 \renewcommand{\ref}[1]{\mbox{\autoref{#1}}}
}
\def\refnamechanges{%
 \renewcommand*{\equationautorefname}[1]{}
 \renewcommand{\sectionautorefname}{sec.\negthinspace}
 \renewcommand{\subsectionautorefname}{sec.\negthinspace}
 \renewcommand{\subsubsectionautorefname}{sec.\negthinspace}
 \renewcommand{\figureautorefname}{Fig.\negthinspace}
 \renewcommand{\tableautorefname}{Tab.\negthinspace}
}
\@ifpackageloaded{babel}{\addto\extrasenglish{\refnamechanges}}{\refnamechanges}

% in case somebody want to have the label "Equation"
%\renewcommand{\eqref}[1]{Equation~(\negthinspace\autoref{#1})}

% that links to image floats jumps to the beginning
% of the float and not to its caption
\usepackage[figure]{hypcap}

% the pages of the TOC is numbered roman
% and a pdf-bookmark for the TOC is added
\let\myTOC\tableofcontents
\renewcommand\tableofcontents{%
  \frontmatter
  \pdfbookmark[1]{\contentsname}{}
  \myTOC
  \mainmatter }

% makes caption labels bold
% for more info about these settings, see
% http://mirrors.ctan.org/macros/latex/contrib/koma-script/doc/scrguien.pdf
\setkomafont{captionlabel}{\bfseries}
\setcapindent{1em}

% enables calculations
\usepackage{calc}

% fancy page header/footer settings
% for more information see section 9 of
% ftp://www.ctan.org/pub/tex-archive/macros/latex2e/contrib/fancyhdr/fancyhdr.pdf
\renewcommand{\chaptermark}[1]{\markboth{#1}{#1}}
\renewcommand{\sectionmark}[1]{\markright{\thesection\ #1}}

% increases the bottom float placement fraction
\renewcommand{\bottomfraction}{0.5}

% avoids that floats are placed above its sections
\let\mySection\section\renewcommand{\section}{\suppressfloats[t]\mySection}
\end_preamble
\options intoc,bibliography=totoc,index=totoc,BCOR10mm,captions=tableheading,titlepage
\use_default_options true
\master TFG.lyx
\begin_modules
customHeadersFooters
\end_modules
\maintain_unincluded_children false
\language spanish
\language_package default
\inputencoding utf8
\fontencoding global
\font_roman "lmodern" "default"
\font_sans "lmss" "default"
\font_typewriter "lmtt" "default"
\font_math "auto" "auto"
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100 100
\font_tt_scale 100 100
\use_microtype false
\use_dash_ligatures true
\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\float_placement h
\paperfontsize 12
\spacing single
\use_hyperref true
\pdf_title "Your title"
\pdf_author "Your name"
\pdf_bookmarks true
\pdf_bookmarksnumbered true
\pdf_bookmarksopen true
\pdf_bookmarksopenlevel 1
\pdf_breaklinks false
\pdf_pdfborder true
\pdf_colorlinks false
\pdf_backref false
\pdf_pdfusetitle false
\pdf_quoted_options "pdfpagelayout=OneColumn, pdfnewwindow=true, pdfstartview=XYZ, plainpages=false"
\papersize a4paper
\use_geometry false
\use_package amsmath 2
\use_package amssymb 2
\use_package cancel 1
\use_package esint 1
\use_package mathdots 1
\use_package mathtools 1
\use_package mhchem 1
\use_package stackrel 1
\use_package stmaryrd 1
\use_package undertilde 1
\cite_engine basic
\cite_engine_type default
\biblio_style plain
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\justification true
\use_refstyle 0
\use_minted 0
\branch NoChildDocument
\selected 0
\filename_suffix 0
\color #ff0000
\end_branch
\index Index
\shortcut idx
\color #008000
\end_index
\secnumdepth 3
\tocdepth 2
\paragraph_separation skip
\defskip medskip
\is_math_indent 1
\math_indentation default
\math_numbering_side default
\quotes_style french
\dynamic_quotes 0
\papercolumns 1
\papersides 2
\paperpagestyle fancy
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Left Header
\begin_inset Argument 1
status open

\begin_layout Plain Layout
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
chaptername
\end_layout

\end_inset


\begin_inset space ~
\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
thechapter
\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
rightmark
\end_layout

\end_inset


\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
Enable page headers and add the chapter to the header line.
\end_layout

\end_inset


\end_layout

\begin_layout Right Header
\begin_inset Argument 1
status open

\begin_layout Plain Layout
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
leftmark
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Left Footer
\begin_inset Argument 1
status open

\begin_layout Plain Layout
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
thepage
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Center Footer

\end_layout

\begin_layout Right Footer
\begin_inset Argument 1
status open

\begin_layout Plain Layout

\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
thepage
\end_layout

\end_inset


\end_layout

\begin_layout Chapter
Desarrollo
\end_layout

\begin_layout Section
Descripción General
\end_layout

\begin_layout Standard
Como se mencionó en la introducción, el desarrollo de esta aplicación será
 principalmente en C++ dado que es el lenguaje en el que se escribe en Unreal
 Engine 5 y ROS2.
 La fase de desarrollo se basa en 2 partes principales.
 Una primera de puesta a punto, o de prototipado, donde se ha experimentado
 con el motor de juego para descubrir la mejor forma de implementar los
 requisitos pedidos.
 Y una segunda fase en la que se desarrolla un visualizador de vuelo.
\end_layout

\begin_layout Section
Fase de prototipado
\end_layout

\begin_layout Standard
Esta ha sido la primera fase del desarrollo del simulador, en la cual se
 han realizado algunas pruebas para definir la forma más eficaz de implementar
 un dron y su movimiento en el 
\shape slanted
sandbox
\shape default
 proporcionado por Unreal.
 Las pruebas realizadas han sido un total de 3 en relación a los elementos
 que personalmente he considerado más importantes para crear un simulador:
 el movimiento, tener una malla, o 
\shape slanted
mesh
\shape default
, con la forma del dron y finalmente el control de la velocidad que usaremos
 para controlar la posición del dron.
\end_layout

\begin_layout Subsection
Pruebas de movimiento de actores:
\end_layout

\begin_layout Standard
Para comenzar, se analizaron las posibilidades de movimiento de actores
 dentro de Unreal.
 En este aspecto cabe destacar que Unreal ofrece una serie clases propias
 que nos permiten crear elementos que situar en la escena a los cuales añadirles
 componentes.
 Estas clases son: actor, peón y personaje, donde cabe decir que las dos
 últimas heredan de actor, lo cual nos indica que todas las funciones de
 actor se encuentran disponibles tanto en peón y personaje.
 Estos elementos son los objetos que podemos añadir a un nivel o escena
 creado en Unreal, es decir son los elementos que interactuarán con el entorno
 y el usuario una vez comienza el juego.
 A pesar de que todas sean clases casi hermanas, las principales diferencias
 entre ellas son en relación a qué utilidad de Unreal son capaces de acceder.
 Los actores son los objetos más limitados ya que no ofrecen opción a que
 los maneje la IA ni permiten tener inputs de teclado.
 Los peones son el siguiente paso en la cadena, los cuales permiten ser
 controlados por la IA de Unreal y permiten inputs de teclado, sin embargo
 no tienen físicas integradas.
 Finalmente, los personajes son actores creados principalmente para simular
 personas, estos incluyen todo lo mencionado previamente y además, integran
 las físicas necesarias para simular un humano.
\end_layout

\begin_layout Standard
En cuanto a los componentes que se pueden añadir a estos actores, son elementos
 que suman funcionalidad a los mismos.
 Podemos encontrar 2 tipos de componentes: componentes de actor y componentes
 de escena.
 El componente de actor no hace nada esencialmente, sin embargo es imprescindibl
e dado que es la base de la jerarquía del resto de componentes.
 Los componentes de escena son aquellos que podemos usar como apoyo para
 incluir funcionalidades a los actores.
\end_layout

\begin_layout Standard
Ahora, todos estos elementos se integran en el editor de Unreal mediante
 jerarquías donde predominan las acciones que tome el componente raíz de
 la misma.
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Graphics
	filename D:/TFG/memoria/imagenes/Screenshot from 2023-04-21 18-50-18.png

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Jerarquías de componentes en un blueprint
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Haciendo uso de estos componentes diseñamos un primer prototipo para estudiar
 el movimiento en los actores y planificar la futura implementación del
 movimiento de un dron.
 Tras investigar y revisar tutoriales de diversas fuentes[tutorial de youtube
 y página de Unreal] decidí crear un componente de escena que se encargara
 de modificar la localización de una 
\shape slanted
mesh
\shape default
 (malla).
 Es decir, crear un componente de escena que fuera el raíz de la jerarquía
 que moviera un modelo 3D.
 En este caso, un cubo cuyo movimiento se basa en un vector de posición
 al que se le pueden ajustar las componentes tanto desde el editor, desde
 un 
\shape slanted
blueprint
\shape default
 como desde el propio código fuente.
 
\end_layout

\begin_layout Standard
A continuación abordamos la cuestión de las colisiones, añadiendo la propiedad
 comunmente conocida como 
\shape slanted
Hitbox 
\shape default
(caja de colisiones).
 Para esto simplemente se añade un componente de escena de tipo hitbox,
 se ajusta al tamaño de la mesh elegida y se configura un gráfico de eventos
 para que cuando el jugador entre en contacto con el objeto este empiece
 a moverse.
 Asimismo se incluye otra Hitbox para delimitar un área amplia alrededor
 de la malla para que en el caso de que detectara que el jugador abandona
 el área el objeto volviera a su posición original.
 
\end_layout

\begin_layout Standard
A continuación se adjuntan los ficheros 
\begin_inset Quotes eld
\end_inset

move.h
\begin_inset Quotes erd
\end_inset

 y 
\begin_inset Quotes eld
\end_inset

move.cpp
\begin_inset Quotes erd
\end_inset

 que contienen el código generado para este componente:
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "D:/TFG/software/Pruebas/moveTest/moveTest/move.h"
lstparams "caption={Header del componente de escena move},label={Img.1}"

\end_inset


\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "D:/TFG/software/Pruebas/moveTest/moveTest/move.cpp"
lstparams "caption={Código fuente del componente de escena move},label={Img.2}"

\end_inset


\end_layout

\begin_layout Standard
Se adjunta también el gráfico de eventos creado para completar su funcionalidad:
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Graphics
	filename D:/TFG/software/Pruebas/moveTest/eventGraph.jpeg
	lyxscale 30
	scale 30
	rotateOrigin center

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout

\size footnotesize
Gráfico de eventos de activación de movimiento por colisión de hitbox
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
El código y el gráfico de eventos fue obtenido de la guía creada por Lötwig
 Fusel [referencia que toque]
\end_layout

\begin_layout Standard
Posteriormente, tras este primer acercamiento a los actores y componentes,
 decidí realizar pruebas para intentar implementar un modo de vuelo típico
 de los drones, el modo 
\shape slanted
Hover.
 
\shape default
Este modo es un modo simple en el que el dron se eleva hasta una altura
 pre establecida y la mantiene hasta que se le envíe una señal para moverse
 o volver a su posición original.
\end_layout

\begin_layout Standard
Esta prueba es muy similar a la anterior dado que también se basa en un
 componente de escena, sin embargo, hay algún cambio respecto al funcionamiento.
 El código para modificar la posición sigue siendo el mismo, solo que en
 este caso, podemos modificar únicamente la altura máxima que queremos que
 alcance el dron y la velocidad del mismo.
 También se implementaron dos funciones, una para comenzar el vuelo y otra
 para resetearlo y cabe mencionar que esta vez no se ha implementado ningún
 grafico de eventos dado que la interacción de esta prueba se basa en mandar
 la señal de activación o de reset.
\end_layout

\begin_layout Standard
Se adjunta tanto el header como el código del componente en cuestión 
\begin_inset Quotes eld
\end_inset


\shape slanted
HoverComponent
\shape default

\begin_inset Quotes erd
\end_inset

:
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "D:/TFG/software/Pruebas/hoverTest/HoverComponent.h"
lstparams "caption={Header del componente de escena HoverComponent},label={Img.3}"

\end_inset


\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "D:/TFG/software/Pruebas/hoverTest/HoverComponent.cpp"
lstparams "caption={Código fuente del componente de escena HoverComponent},label={Img.4}"

\end_inset


\end_layout

\begin_layout Subsection
Prueba de importación de mallas:
\end_layout

\begin_layout Standard
Durante el desarrollo de la prueba anteriormente descrita, se buscaron formas
 de poder integrar un modelo 3D, conocido como 
\shape slanted
mesh
\shape default
, de un cuadricóptero en el editor de Unreal y como hacer que los componentes
 lo movieran.
 
\end_layout

\begin_layout Standard
Para empezar busqué en internet un modelo 3D gratuito de un cuadricóptero[refere
ncia a la página del modelo 3D del dron].
 Una vez descargado faltaba importarlo a la carpeta de contenidos de Unreal
 Engine para su uso.
 Cabe mencionar que estos modelos 3D han de ser exportados de sus respectivas
 aplicaciones en formato .fbx ya que este es el que reconoce Unreal.
 El proceso de importación es muy simple, consiste en arrastrar el archivo
 al editor y tras una simple ventana de configuración ya estaría disponible
 el modelo para su uso.
 El modelo seleccionado fue el siguiente:
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Graphics
	filename D:/TFG/memoria/imagenes/Screenshot from 2023-04-21 18-58-01.png
	lyxscale 30
	scale 30

\end_inset


\begin_inset Caption Standard

\begin_layout Plain Layout
Mesh del dron en el entorno de Unreal
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Si se desea, Epic Games también cuenta con una plataforma en la que los
 usuarios pueden subir sus modelos 3D ya sea de niveles u objetos a una
 tienda on-line.
 La desventaja es que la mayoría del contenido es de pago.
 
\end_layout

\begin_layout Standard
Con esto quedaba solventado el problema de poder disponer de un modelo tridimens
ional de un dron.
 Un objetivo de futuro será determinar si Unreal genera las colisiones automátic
amente al proporcionarle una 
\shape slanted
hitbox
\shape default
 al modelo o si estas han de ser programadas desde 0.
\end_layout

\begin_layout Subsection
Prueba de implementación de un control diferencial de la velocidad:
\end_layout

\begin_layout Standard
Finalmente y tras las primeras pruebas de movimiento decidimos crear un
 peón ya que este es el objeto ideal sobre el que crear un dron.
 Así pues, tras crear una clase en C++ de un peón, implementamos en la misma
 un control diferencial de la velocidad, un concepto simple basado en 3
 vectores, uno para establecer la velocidad deseada, otro para definir la
 velocidad real del dron y un tercero que se encarga de calcular un delta
 con la velocidad real actual del dron, la velocidad objetivo y el tiempo
 transcurrido.
 
\end_layout

\begin_layout Standard
Es relevante considerar que Unreal proporciona una función 
\shape slanted
tick
\shape default
 dentro de todas sus clases, la cual se ejecuta a cada fotograma generado
 por el motor y ejecuta las instrucciones descritas en la misma.
 Al mismo tiempo, esta función nos proporciona una variable 
\shape slanted
DeltaTime
\shape default
 la cual lleva la cuenta del tiempo que pasa dentro del editor durante la
 ejecución del programa.
 Esta función será la que más carga computacional tenga al final, dado que
 es la que utilizaremos para poder generar un movimiento fluido en un futuro.
\end_layout

\begin_layout Standard
Otra función generada automáticamente y que merece la pena considerar es
 
\shape slanted
BeginPlay
\shape default
, esta se ejecuta en el primer instante en que se entra al nivel creado
 y solo esa vez.
 Resulta útil para establecer variables iniciales o si se desea almacenar
 la posición inicial de algún objeto.
\end_layout

\begin_layout Standard
Una vez explicados los conceptos anteriores pasamos a la implementación
 del control en cuestión, una implementación simple y que nos permite configurar
 una velocidad máxima, una mínima y una constante para ajustar la velocidad
 en el calculo del delta de la velocidad.
 La implementación quedaría así:
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "D:/TFG/software/droneSim/DronePawn.h"
lstparams "caption={Header del peón DronePawn},label={Img.5}"

\end_inset


\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "D:/TFG/software/droneSim/DronePawn.cpp"
lstparams "caption={Código fuente del peón DronePawn},label={Img.6}"

\end_inset


\end_layout

\begin_layout Standard
Asimismo, gracias a utilizar un peón tenemos acceso a entradas de teclado
 mediante la función SetupPlayerInputComponent(), la cual nos permite aumentar
 y disminuir los valores de las componentes del vector de la velocidad objetivo
 mediante teclas durante la ejecución del nivel.
 Muy relevante tener en cuenta que estos 
\shape italic
keybinds
\shape default
 también han de configurarse dentro del editor de Unreal:
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Graphics
	filename D:/TFG/memoria/imagenes/Screenshot from 2023-04-21 18-59-47.png
	lyxscale 30
	scale 20

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Asociación de teclas en la configuración del proyecto
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
Y no solo eso, si no que además hemos de configurar el DefaultPawn del nivel
 al peón de la clase que hemos creado DronePawn, dado que es este 
\begin_inset Quotes eld
\end_inset

peón por defecto
\begin_inset Quotes erd
\end_inset

 el que recoge las entradas del teclado y las transfiere al propio peón.
 Este cambio solamente lo podemos realizar desde el código del modo de juego
 que se generó automáticamente al crear el proyecto en Unreal.
 Dentro del archivo NombreProyectoGameModeBase.h y NombreProyectoGameModeBase.cpp
 hemos de añadir las 2 siguientes líneas (En este caso el nombre de los
 archivos es droneSimGameModeBase.h y droneSimGameModeBase.cpp):
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "D:/TFG/software/droneSim/droneSimGameModeBase.h"
lstparams "caption={Header del modo de juego droneSimGameModeBase},label={Img.7}"

\end_inset


\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "D:/TFG/software/droneSim/droneSimGameModeBase.cpp"
lstparams "caption={Código fuente del modo de juego droneSimGameModeBase},label={Img.8}"

\end_inset


\end_layout

\begin_layout Standard
Una vez realizados todos estos cambios veremos que aparece la siguiente
 información en el editor al ejecutar y seleccionar el peón:
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Graphics
	filename D:/TFG/memoria/imagenes/Screenshot from 2023-04-21 19-00-30.png
	lyxscale 30
	scale 20

\end_inset


\begin_inset Graphics
	filename D:/TFG/memoria/imagenes/Screenshot from 2023-04-21 19-00-17.png
	lyxscale 30
	scale 20

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Valores del editor del modo de juego y los vectores asociados al peón
\end_layout

\end_inset


\end_layout

\end_inset

Ya configurado y testado el correcto funcionamiento de las funciones previamente
 descritas, el siguiente paso es modificar la posición del propio peón con
 las velocidades calculadas.Tras esta última prueba concluimos que el movimiento
 del dron basado en este control diferencial es lo necesario para simular
 correctamente el movimiento y poder realizar una integración con ROS 2
 ya que pretendemos que el movimiento se rija mediante la velocidad que
 se enviará mediante los servicios de mensajería ofrecidos por este framework.
\end_layout

\begin_layout Standard
\begin_inset Newpage pagebreak
\end_inset


\end_layout

\begin_layout Section
Desarrollo final
\end_layout

\begin_layout Standard
A la vista de los resultados de las pruebas anteriormente descritas, se
 realizo un reajuste de los objetivos planteados en un principio.
 Finalmente, este trabajo ha consistido en la realización de un visualizador
 de vuelo de un dron en un entorno tridimensional.
 Esto sentará las bases para futuros trabajos en los cuales se itere sobre
 los programas aquí desarrollados y completar así el simulador completo.
\end_layout

\begin_layout Standard
El desarrollo del visualizador de vuelo consistirá de tres partes: el desarrollo
 de un sistema publicador subscriptor de ROS2 para poder comunicar el dron
 dentro del entorno de UE5, el desarrollo del movimiento de un dron en base
 a las coordenadas publicadas en el publicador y la importación de escenarios
 tridimensionales en UE5 y sus capacidades.
\end_layout

\begin_layout Subsection
Desarrollo de un sistema pub/sub de ROS2:
\end_layout

\begin_layout Standard
En la realidad, el control remoto de un dron es posible gracias a la biblioteca
 de C previamente descrita ROS2.
 Esta permite el intercambio de todo tipo de mensajes entre un publicador
 y un subscriptor, los cuales se pueden desarrollar libremente para cada
 caso particular.
 Para este visualizador de vuelo la intención es poder leer coordenadas
 de la entrada estandar, que el publicador lo convierta en un vector y lo
 publique para ser recibido posteriormente por el subscriptor.
 Este subscriptor va a ser un tanto especial puesto que ha de ser accesible
 desde un peón dentro de Unreal para poder moverlo más adelante.
 
\end_layout

\begin_layout Standard
Este último detalle mencionado es muy importante puesto que, para conseguirlo,
 habremos de hacer del subscriptor una librería que se pueda abrir en Unreal
 y permita usar sus funciones para recibir los mensajes del publicador.
 Esta tarea fue ampliamente simplificada gracias al trabajo de Juan Pares
 Guillen[link de su github] y Santiago Tapia, quienes desarrollaron un subscript
or para su trabajo el cual he podido importar a mi proyecto y hacer uso
 del mismo puesto que la funcionalidad que buscaba implementar es similar.
 Este subscriptor cuenta con 3 funciones, start(), update() y end().
 Cada una de estas funciones tiene un propósito y son las que más adelante
 importaremos en el peón de UE5:
\end_layout

\begin_layout Itemize
start(): Esta función se encarga de inicializar el subscriptor y subscribirse
 al canal (
\shape slanted
topic
\shape default
) creado por el publicador.
 Asimismo configurará su función de 
\shape italic
callback
\shape default
 a update(), encargada de recibir los mensajes.
\end_layout

\begin_layout Itemize
update(): Esta es la función de 
\shape italic
callback
\shape default
, la cual recibirá los mensajes que se vayan publicando.
 Esta función será ejecutada según el intervalo de tiempo puesto en su inicializ
ación dentro de la función start().
 
\end_layout

\begin_layout Itemize
end(): Se encarga de destruir el subscriptor y liberar la memoria ocupada.
\end_layout

\begin_layout Standard
Esta clase hace uso del tipo de mensaje Vector3, tipo propio de ROS2 el
 cual necesita que se incluya en la clase y posteriormente ha de indicarse
 en el CMAKE para su correcta compilación.
\end_layout

\begin_layout Standard
A continuación, en lo relacionado al publicador de ROS2 se toma como base
 el publicador de ejemplo que ROS2 propone en sus tutoriales[ros2 tutoriales].
 La base es la misma, solo que se hace uso de un tipo de mensaje diferente,
 el Vector3, igual que en el subscriptor.
 Una vez hecho esto, el otro cambio importante a realizar es la lectura
 de los datos, para lo cual se hace uso de la lectura por entrada estandar.
 Este método es simple, solo que hemos de tener en cuenta que hay que transferir
le los datos en la línea de ejecución.
 En este caso se hace mediante el comando 
\begin_inset Quotes eld
\end_inset

cat
\begin_inset Quotes erd
\end_inset

 y el uso de una tubería para pasar las coordenadas redactadas en un fichero
 
\begin_inset Quotes eld
\end_inset

coordinates.txt
\begin_inset Quotes erd
\end_inset

 que se encuentra en la carpeta de ejecución del publicador.
\end_layout

\begin_layout Standard
Con esto tenemos creados los ficheros fuente tanto del publicador como del
 subscriptor:
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "D:/TFG/software/Final pawn/ros2_package/droneCom/src/subscriber_member_function.h"
lstparams "caption={Header de subscriptor ueSub},label={Img.9}"

\end_inset


\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "D:/TFG/software/Final pawn/ros2_package/droneCom/src/subscriber_member_function.cpp"
lstparams "caption={Código fuente del subscriptor ueSub},label={Img.10}"

\end_inset


\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "D:/TFG/software/Final pawn/ros2_package/droneCom/src/CoordinatesPublisher.cpp"
lstparams "caption={Código fuente del publicador CoordinatesPublisher},label={Img.11}"

\end_inset


\end_layout

\begin_layout Standard
Ahora necesitamos poder compilarlos, para lo cual seguimos las indicaciones
 de la guía oficial de ROS2[guía de ROS2].
 Puesto que nuestros programas son diferentes a los creados en el tutorial
 hemos de realizar modificaciones en el CMAKE para conseguir compilar con
 éxito.
 Dado que usamos un tipo de mensajes diferente al indicado en la guía, tenemos
 que indicar que se busque el paquete donde se encuentra el tipo de mensaje
 Vector3, el paquete 
\begin_inset Quotes eld
\end_inset

geometry_msgs
\begin_inset Quotes erd
\end_inset

, además de tener que usarlo también en los 
\begin_inset Quotes eld
\end_inset

add_executable
\begin_inset Quotes erd
\end_inset

 del publicador y del subscriptor.
 Finalmente es necesario añadir también un 
\begin_inset Quotes eld
\end_inset

add_library
\begin_inset Quotes erd
\end_inset

 para crear así la librería del subscriptor que queremos utilizar en Unreal.
 
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "D:/TFG/software/Final pawn/ros2_package/droneCom/CMakeLists.txt"
lstparams "caption={CMAKE del proyecto},label={Img.12}"

\end_inset


\end_layout

\begin_layout Standard
Tras estos cambios al CMAKE, podemos compilar el proyecto con la herramienta
 
\shape italic
colcon
\shape default
 de ROS2 creando así la librería del subscriptor y consecuentemente un ejecutabl
e del publicador.
\end_layout

\begin_layout Standard
El siguiente paso es gestionar el uso de la librería dentro de un peón en
 Unreal.
 
\end_layout

\begin_layout Subsection
Desarrollo del peón en UE5:
\end_layout

\begin_layout Standard
Para este desarrollo final, decidimos hacer uso de un peón, por las razones
 mencionadas en la parte de prototipado.
 Este peón cumplirá dos funciones clave para este visualizador, la primera
 y más obvia gestionará la recepción de coordenadas mediante el uso de la
 librería de ROS2 previamente creada, la segunda función será mover el dron
 en el entorno de Unreal acorde con las coordenadas recibidas desde el publicado
r.
\end_layout

\begin_layout Standard
Para conformar este peón haremos uso de una variedad de funciones, algunas
 previamente mencionadas pues son las generadas automáticamente por Unreal,
 otras auxiliares creadas por nosotros y otras importadas desde la librería
 del subscriptor.
 Como en la fase de prototipado, nos encontramos una vez más con las funciones
 BeginPlay(), Tick(), el constructor del propio peón, en este caso ADronePawnCom
() y además aparecerá una función propia de Unreal no mencionada previamente,
 el EndPlay() solo que esta ha de ser sobrescrita y normalmente no se genera
 de forma automática en el fichero del peón.
 En cada una de estas podremos encontrar otras 3 funciones auxiliares las
 cuales implementan las funcionalidades deseadas.
 Al mismo tiempo se hará uso de las funciones importadas en 3 de las 4 funciones
 mencionadas anteriormente.
 
\end_layout

\begin_layout Standard
En la función BeginPlay(), veremos la función dlImport(), la cual se encarga
 de gestionar la apertura de la librería dinámica que contiene las funciones
 necesarias para hacer uso del subscriptor.
 Dentro de esta función veremos un 
\begin_inset Quotes eld
\end_inset

dlopen
\begin_inset Quotes erd
\end_inset

 con su respectivo control de fallos y la importación de las funciones de
 la librería a este fichero mediante el uso de las funciones 
\begin_inset Quotes eld
\end_inset

dlsym
\begin_inset Quotes erd
\end_inset

.
 Como se puede observar[insertar referencia] estamos importando estas funciones
 como punteros a función puesto que esta es la única manera de poder hacer
 uso de las mismas.
 Para que este método sea operativo es necesario definir en el header del
 archivo[insertar referencia] estas funciones mediante un typedef y crear
 aquí las variables en las que almacenaremos posteriormente estos punteros.
 
\end_layout

\begin_layout Standard
En el constructor podremos encontrar el método setComponents() que como
 indica su nombre genera los componentes que irán colgados de este peón
 y podremos ver más adelante en la jerarquía dentro de su blueprint.
 Los componentes aquí generados son una cámara para poder ver la malla del
 dron, un SpringArmComponent, el cual nos ayudará a configurar la posición
 relativa de la cámara respecto del dron y finalmente un RootComponent,
 del que colgar el resto de los componentes, y un MeshComponent para poder
 darle un cuerpo al dron.
\end_layout

\begin_layout Standard
A continuación, en la función de Tick(), veremos que se realiza una llamada
 a la función move(FVector pos1), la cual precisa de un argumento de tipo
 vector para funcionar.
 Esta realizará la función de mover el dron en el entorno seleccionado siguiendo
 el modelo de movimiento que vimos en la fase de prototipado
\begin_inset CommandInset ref
LatexCommand vpageref
reference "Img.2"
plural "false"
caps "false"
noprefix "false"

\end_inset

, solo que simplificado.
\end_layout

\begin_layout Standard
Finalmente, la función EndPlay().
 Esta función es propia de todo actor de Unreal, y por herencia lo es de
 las clases peón y character.
 Esta se ejecuta al quitar, el peón del nivel caso que se da también al
 terminar el nivel o juego.
 De normal esta función unicamente hace un log en la consola indicando que
 el peón ha sido eliminado del nivel y la razón.
 Sin embargo, esta función se puede sobrescribir, lo que quiere decir que
 como BeginPlay(), podemos crear una versión personalizada que será la que
 se ejecute.
 En nuestro caso la reescribimos y hacemos que ejecute una función de la
 librería y finalmente libere la memoria ocupada por la misma.
 Esto es necesario puesto que si no liberásemos la memoria cerrando la librería
 esto provocaría que el programa fallase si se trata de ejecutar 2 veces
 seguidas.
\end_layout

\begin_layout Standard
Esto concluye la estructura general del dron.
 Ahora es importante mencionar el uso de la biblioteca dinámica.
 Las 3 funciones de las que se compone y las cuales utilizamos en este peón
 son: start(), update(vector3_transfer) y end().
 La funcionalidad de cada una se puede ver en 
\begin_inset CommandInset ref
LatexCommand vpageref
reference "Img.10"
plural "false"
caps "false"
noprefix "false"

\end_inset

.
 Sin embargo aquí vemos que la función update lleva un argumento, este es
 un argumento de retorno en el cual se almacenará el mensaje recibido para
 luego poder utilizar el vector en el movimiento del peón.
 Las llamadas a estas funciones se encuentran en lugares específicos dada
 la naturaleza de la ejecución en Unreal.
 
\end_layout

\begin_layout Standard
Vimos previamente en la fase de prototipado que las funciones se ejecutan
 de forma específica.
 El constructor y BeginPlay() se ejecutan un única vez al comenzar la ejecución
 general del nivel que contenga el peón, es por esto que aquí se realizan
 las llamadas a las funciones setComponents() y dlImport() para realizar
 la configuración inicial del dron.
 Además de esas dos funciones aquí ya realizamos la primera llamada a una
 de las funciones de la librería, la función start() para inicializar el
 subscriptor.
 Prestando atención a la función de Tick(), esta se ejecuta en cada fotograma
 procesado por Unreal, por lo que en esta realizamos la segunda llamada
 funciones de librería, en este caso a update(), para recibir los mensajes
 con los vectores de posición a donde deseamos mover el dron.
 Es por este comportamiento de 
\begin_inset Quotes erd
\end_inset

bucle
\begin_inset Quotes erd
\end_inset

 por lo que aquí también llamamos a la función move().
 Finalmente la función EndPlay() se ejecuta una sola vez al terminar la
 ejecución y aquí realizamos la tercera y última llamada a la librería con
 la función end() que se encarga de cerrar el subscriptor.
\end_layout

\begin_layout Standard
Con este desarrollo obtenemos el código fuente del peón 
\begin_inset Quotes eld
\end_inset

DronePawnCom
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "D:/TFG/software/Final pawn/DronePawnCom.h"
lstparams "caption={Header de DronePawnCom.h},label={Img.13}"

\end_inset


\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "D:/TFG/software/Final pawn/DronePawnCom.cpp"
lstparams "caption={Código fuente de DronePawnCom},label={Img.14}"

\end_inset


\end_layout

\begin_layout Subsection
Importación de escenarios a UE5:
\end_layout

\begin_layout Standard
Uno de los objetivos de este trabajo es mantener una modularidad entre el
 entorno y el dron en si.
 Esto es bastante sencillo en Unreal Engine tanto para escenarios importados
 de internet como para los creados específicamente.
 El proceso solo requiere de ficheros en formato .fbx y normalmente basta
 con arrastrar dicho fichero al cajón de contenidos del editor de Unreal
 y esto provocará que aparezca una ventana de configuración.
 Esta ventana permite modificar varios campos de las mallas a importar.
 De normal no es necesario modificar nada y basta con importar el .fbx, guardar
 los contenidos importados, seleccionarlos y arrastrarlos al nivel en el
 que estemos trabajando.
\end_layout

\begin_layout Standard
Este método sirve cuando tenemos escenarios con pocas o ninguna textura
 o no requieran de cambios, es decir sean mallas simples.
 Para este trabajo he decidido hacer uso de un mapa de Londres[referencia
 a la página del modelo].
 Este modelo cuenta con dos versiones, una texturizada y otra no.
\end_layout

\begin_layout Standard
La no texturizada sigue el método de importación descrito al principio,
 se selecciona el fichero, se arrastra, se guardan las mallas y ya está
 listo para ser añadido al nivel, generando el siguiente resultado
\end_layout

\begin_layout Standard
(fotografías del entorno)
\end_layout

\begin_layout Standard
Sin embargo, la texturizada necesita realizar algunas modificaciones.
 En el caso de este modelo 3D, de acuerdo a la guía proporcionada por su
 creador[referencia a la guía].
 En esta se hablan de los pasos a seguir para la correcta importación del
 mapa con sus texturas.
\end_layout

\begin_layout Standard
Lo primero es crear un material base en Unreal, para poder realizar configuracio
nes específicas de algunas de las mallas que vamos a importar, como por
 ejemplo el agua, a la que le daremos reflejos más adelante.
 Este material no tiene ningún requerimiento específico.
 Ahora, hemos de modificar este material y en su gráfico crear un 
\begin_inset Quotes eld
\end_inset

Texture Sample
\begin_inset Quotes erd
\end_inset

 dándole un nombre propio, convertirlo en un parámetro y configurar su textura
 base a cualquier textura.
 
\end_layout

\begin_layout Standard
(insertar foto de la configuración del material)
\end_layout

\begin_layout Standard
Esta versión texturizada del mapa de Londres, ha sido distribuida en 4 carpetas
 dado su gran tamaño.
 Estas 4 representan cada una una zona de Londres, noreste, noroeste, sureste,
 suroeste, contando en su totalidad con casi 900 mallas.
 Las modificaciones que hemos de realizar en la ventana de importación se
 centran en su posición, pues hemos de modificar la x a x = –53199840 y
 la y a y = 18100590.
 Al mismo tiempo, hemos de hacer uso del material creado previamente; en
 la zona de MATERIAL hemos de seleccionar la opción de 
\begin_inset Quotes erd
\end_inset

crear nuevos materiales instanciados
\begin_inset Quotes erd
\end_inset

 en el campo 
\begin_inset Quotes erd
\end_inset

Material Import...
\begin_inset Quotes erd
\end_inset

 y seleccionar nuestro material con su textura base, la que creamos en su
 grafico (en mi caso BaseColor).
 Puesto que esta configuración es la misma para todos los ficheros basta
 con configurarlo una vez y esta se mantiene entre importaciones.
 Tras esto podemos importar todos los .fbx.
 Una vez tenemos todo en nuestro editor podemos seleccionarlos y arrastrarlos
 a la ventana del nivel para ver la ciudad de Londres a escala.
\end_layout

\begin_layout Standard
Una vez tenemos todas las mallas puestas en el mapa podemos añadir detalles
 al agua del rio Támesis.
 Para esto hemos de modificar ese material base que creamos al principio.
 Hemos de añadirle un parámetro a su campo de 
\begin_inset Quotes erd
\end_inset

Roughness
\begin_inset Quotes erd
\end_inset

.
\end_layout

\begin_layout Standard
(foto del grafico)
\end_layout

\begin_layout Standard
Una vez añadido y compilado, podemos entrar en las mallas del agua y cambiar
 este valor para darle reflejos al agua y tener una textura más detallada.
\end_layout

\begin_layout Standard
(foto del agua antes y después)
\end_layout

\begin_layout Standard
El proceso de importado de escenarios puede variar según el creador del
 escenario y cómo se configuren los ficheros a importar.
 Asimismo, el nivel de detalle de las mallas y texturas puede mejorar mucho
 dependiendo del creador de las mismas y de la potencia de la maquina que
 las use.
 En este campo Unreal Engine 5 tiene un gran potencial pudiendo llegar a
 tener una calidad fotorrealistica como puede ser ejemplo el juego UNRECORD[refe
rencia al juego] que se encuentra en desarrollo por el estudio de videojuegos
 
\shape slanted
Drama
\shape default
[Referencia al estudio], que cuenta con visuales hiperrealistas, que asemejan
 a una grabación real.
\end_layout

\begin_layout Standard
\begin_inset Branch NoChildDocument
inverted 0
status collapsed

\begin_layout Standard
\begin_inset CommandInset bibtex
LatexCommand bibtex
bibfiles "thesisExample"
options "alpha"

\end_inset


\end_layout

\begin_layout Standard
\begin_inset CommandInset nomencl_print
LatexCommand printnomenclature
set_width "custom"
width "2.5cm"

\end_inset


\end_layout

\end_inset


\end_layout

\end_body
\end_document
